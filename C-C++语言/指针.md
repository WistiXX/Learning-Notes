==一个值，表示某个内存地址==

# **指针变量**

- 可存储其他变量的内存地址
- 可通过内存地址直接访问和修改被指变量的值

```C
0x7ffeeaae08d8         //内存地址
```

### 声明

```C
type *var_name;
```

### 赋值

```C
int *p;         //声明指针变量p
p = &a;         //将a的内存地址赋值给p
```

### 运用

```C
int *a;        //声明整形指针变量a
a = &x;        //将x的内存地址赋值给a
*a = 10        //修改a就是修改被指的变量
```

# 指针的算数运算

可以进行四种`++`,`--`,`+`,`-`运算

## 自增与自减

可以在不影响内存位置中实际值的情况下，移动指针到下一个内存位置

- 自增（`++`）
    
    ```C
    p++; // 将指针移动到下一个数据类型的位置
    ```
    
    - 使p增加一个数据类型的大小
        - 如p是指向地址为1000的`int`指针，那它将指向1004_（32位系统下，`int`占用4字节）。_
- 自减（`--`）
    
    ```C
    p--; // 将指针移动到前一个数据类型的位置
    ```
    
    - 使p减少一个数据类型的大小   
        - 如p是指向地址为1000的字符指针，那它将指向999_（`char`在C语言中占用1字节）_   

**举例：**在数组中使用   

```C
\#include <stdio.h>

int main() {
    char str[] = "Hello";
    char *ptr = str;  // 指针指向字符串的第一个字符

    printf("初始字符: %c\n", *ptr);  // 输出 H

    ptr++;  // 递增指针，使其指向下一个字符
    printf("递增后字符: %c\n", *ptr);  // 输出 e

    return 0;
}
```

### 总结

- ==每一次====**递增**====，都会指向====**下一个**====元素的存储单元==
- ==每一次====**递减**====，都会指向====**前一个**====元素的存储单元==
- ==在递增和递减时跳跃的字节数取决于变量数据类型长度，比如====`char`====是一个字节==

## **指针与整数的加减**

- 加法（`+`）
    
    ```C
    p = p + n; // 将指针向前移动'n'个元素
    ```
    
    - 指针会向前移动`n * sizeof(数据类型)`个字节
- 减法（`-`）
    
    ```C
    p = p - n; // 将指针向后移动'n'个元素
    ```
    
    - 指针会向后移动`n * sizeof(数据类型)`个字节

**举例：**

```C
int arr[] = {10, 20, 30, 40, 50};
int *p = arr;                       // 指向数组的第一个元素

p = p + 2;                          // 将指针向前移动2个int元素的位置

printf("%d\n", *p);                 // 输出30
```

# 指针的比较

==主要用于确定两个指针是否指向相同的内存位置或确定一个指针是否位于另一个指针之前或之后==

==另外指针比较只有在指向同一个数组或同一内存块时才有意义，否则行为未定义==

可以使用关系运算符（`==`、`!=`、`<`、`>`、`<=`、`>=`）比较指针

## 相等比较

```C
\#include <stdio.h>
 
int main() {
    int a = 5;
    int b = 10;
    int *ptr1 = &a;
    int *ptr2 = &a;
    int *ptr3 = &b;
 
    if (ptr1 == ptr2) {
        printf("ptr1 和 ptr2 指向相同的内存地址\n");  // 这行会被输出
    } else {
        printf("ptr1 和 ptr2 指向不同的内存地址\n");
    }
 
    if (ptr1 != ptr3) {
        printf("ptr1 和 ptr3 指向不同的内存地址\n");  // 这行会被输出
    } else {
        printf("ptr1 和 ptr3 指向相同的内存地址\n");
    }
 
    return 0;
}
```

## 大小比较

```C
\#include <stdio.h>

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr1 = &arr[1];  // 指向 arr[1]，值为 20
    int *ptr2 = &arr[3];  // 指向 arr[3]，值为 40

    if (ptr1 < ptr2) {
        printf("ptr1 在 ptr2 之前\n");  // 这行会被输出
    } else {
        printf("ptr1 在 ptr2 之后或相同位置\n");
    }

    if (ptr1 > ptr2) {
        printf("ptr1 在 ptr2 之后\n");
    } else {
        printf("ptr1 在 ptr2 之前或相同位置\n");  // 这行会被输出
    }

    return 0;
}
```

### 总结

- 相等比较 (`==` 和 `!=`): 用于判断两个指针是否指向相同的内存位置。
- 大小比较 (`<`, `>`, `<=`, `>=`): 通常用于指针遍历数组或内存块时，判断一个指针是否在另一个指针之前或之后。

# 指向指针的指针

==当定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置==

```C
int **var;    //一个指向 int 类型指针的指针
 
```

**举例：**

```C
\#include <stdio.h>
 
int main ()
{
   int  V;
   int  *Pt1;
   int  **Pt2;
 
   V = 100;
 
   /* 获取 V 的地址 */
   Pt1 = &V;
 
   /* 使用运算符 & 获取 Pt1 的地址 */
   Pt2 = &Pt1;
 
   /* 使用 pptr 获取值 */
   printf("var = %d\n", V );
   printf("Pt1 = %p\n", Pt1 );
   printf("*Pt1 = %d\n", *Pt1 );
    printf("Pt2 = %p\n", Pt2 );
   printf("**Pt2 = %d\n", **Pt2);
 
   return 0;
}
```

# 传递指针给函数

？（在函数分类下）

# 从函数返回指针

？

# NULL指针（空指针）    

==如没有确切的地址可以赋值，为指针变量赋值null是一个好习惯==

- null指针是定义在标准库中的值为零的常量

```C
0x0             //null指针返回结果
```

- 可以用于初始化指针。即表明该指针还没指向任何对象。
- 可以避免未初始化而导致”野指针”（包含随机值）出现                            
- 可以检查一个指针是否有效。在操作指针之前，可以用`NULL`来判断它是否已被赋值

# 函数指针

==指向函数的指针==

```C
// 声明一个返回类型为int，参数为两个int的函数指针
int (*funcPtr)(int, int);
```

**举例**

```C
\#include <stdio.h>
 
int max(int x, int y)
{
    return x > y ? x : y;
}
 
int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = & max; // &可以省略
    int a, b, c, d;
 
    printf("请输入三个数字:");
    scanf("%d %d %d", & a, & b, & c);
 
    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c); 
 
    printf("最大的数字是: %d\n", d);
 
    return 0;
}
```